diff -r ../final/3d.cc ./3d.cc
42,46d41
<   //cast added
<   // int iter = 0;
<   // float matInvProjModel_float[16];
<   // for (iter = 0; iter < 16; iter++)
<   //   matInvProjModel_float[iter]= (float)camP.matInvProjModel[iter];
49,50d43
< 
< 
Only in ../final/: 3d.o
Only in ../final/: cdecl.h
Only in .: diff.txt
diff -r ../final/distance_est.cc ./distance_est.cc
22a23
> #include "mandelboxde.h"
24c25,34
< extern MandelBoxParams mandelBox_params;
---
> #include "color.h"
> //#include "mandelbox.h" //already included
> #ifdef _OPENACC
> #include <accelmath.h>
> #else
> #include <math.h>
> #endif
> 
> //using namespace std;
> //extern MandelBoxParams mandelBox_params; // KA no global variables!
25a36
> float MandelBulbDistanceEstimator(const vec3 &p0, const MandelBoxParams &params);
28,30c39,43
< float DE(const vec3 &p)
< {
<   
---
> float DE(const vec3 &p, MandelBoxParams &mandelBox_params)
> {	
> #ifdef BULB
>   float d = MandelBulbDistanceEstimator(p, mandelBox_params);
> #else
33a47
> #endif
35a50,90
> 
> float MandelBulbDistanceEstimator(const vec3 &p0, const MandelBoxParams &params)
> {
>   vec3 z = COPY(p0);
>   
>   float dr = 1.0;
>   float r = 0.0;
> 
>   float Bailout = params.rMin;
>   float Power = params.rFixed;
> 
>   for (int i=0; i < params.num_iter; i++) 
>     {
>       r = MAGNITUDE_RET(z);
> 	  
>       if(r > Bailout){ break; }
> 
>       float theta = acos(z.z/r);
>       float phi   = atan2(z.y, z.x);
>       dr = pow(r, Power - 1.0) * Power * dr + 1.0;
> 
>       float zr = pow(r, Power);
>       theta     = theta * Power;
>       phi       = phi * Power;
> 
>       z.x = zr*sin(theta)*cos(phi);
>       z.y = zr*sin(phi)*sin(theta);
>       z.z = zr*cos(theta);
> 
>       z.x = z.x + p0.x;
>       z.y = z.y + p0.y;
>       z.z = z.z + p0.z;
>     }
> 
>   return 0.5*log(r)*r/dr;
> }
> 
> 
> 
> 
> 
Only in ../final/: distance_est.o
Only in ../final/: ._.DS_Store
Only in ../final/: .DS_Store
Only in ../final/: frames
diff -r ../final/getcolor.cc ./getcolor.cc
1,4d0
< /*
<    This file is part of the Mandelbox program developed for the course
<     CS/SE  Distributed Computer Systems taught by N. Nedialkov in the
<     Winter of 2015-2016 at McMaster University.
6d1
<     Copyright (C) 2015-2016 T. Gwosdz and N. Nedialkov
8,11d2
<     This program is free software: you can redistribute it and/or modify
<     it under the terms of the GNU General Public License as published by
<     the Free Software Foundation, either version 3 of the License, or
<     (at your option) any later version.
13,16d3
<     This program is distributed in the hope that it will be useful,
<     but WITHOUT ANY WARRANTY; without even the implied warranty of
<     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<     GNU General Public License for more details.
18,25d4
<     You should have received a copy of the GNU General Public License
<     along with this program.  If not, see <http://www.gnu.org/licenses/>.
< */
< #include "color.h"
< #include "renderer.h"
< #include "vector3d.h"
< #include <cmath>
< #include <algorithm>
27,81d5
< using namespace std;
< 
< //---lightning and colouring---------
< static vec3 CamLight(1.0,1.0,1.0);
< static float CamLightW = 1.8;// 1.27536;
< static float CamLightMin = 0.3;// 0.48193;
< //-----------------------------------
< static const vec3 baseColor(1.0, 1.0, 1.0);
< static const vec3 backColor(0.4,0.4,0.4);
< //-----------------------------------
< 
< void lighting(const vec3 &n, const vec3 &color, const vec3 &pos, const vec3 &direction,  vec3 &outV)
< {
<   vec3 nn = n -1.0;
<   float ambient = max( CamLightMin, nn.Dot(direction) )*CamLightW;
<   outV = CamLight*ambient*color;
< }
< 
< vec3 getColour(const pixelData &pixData, const RenderParams &render_params,
< 	       const vec3 &from, const vec3  &direction)
< {
<   //colouring and lightning
<   vec3 hitColor = baseColor;
<   
<   if (pixData.escaped == false) 
<     {
<       //apply lighting
<       lighting(pixData.normal, hitColor, pixData.hit, direction, hitColor);
<       
<       //add normal based colouring
<       if(render_params.colourType == 0 || render_params.colourType == 1)
< 	{
< 	  hitColor = hitColor * pixData.normal;
< 	  hitColor = (hitColor + 1.0)/2.0;
< 	  hitColor = hitColor*render_params.brightness;
< 	  
< 	  //gamma correction
< 	  clamp(hitColor, 0.0, 1.0);
< 	  hitColor = hitColor*hitColor;
<     
< 	}
<       if(render_params.colourType == 1)
< 	{
< 	  //"swap" colors
< 	  float t = hitColor.x;
< 	  hitColor.x = hitColor.z;
< 	  hitColor.z = t;
< 	}
<     }
<   else 
<     //we have the background colour
<     hitColor = backColor;
<   
<   return hitColor;
< }
Only in .: getcolor.h
Only in ../final/: getcolor.o
diff -r ../final/getparams.c ./getparams.c
30,34c30
< static char buf[BUF_SIZE];
< 
< void getParameters(char *filename, float *camera_position_array, float *camera_position_changes_array, 
< 	float *camera_angle_array, float *camera_angle_changes_array,
< 	 int frame_no, CameraParams *camP, RenderParams *renP, MandelBoxParams *boxP)
---
> void getParameters(char *filename, CameraParams *camP, RenderParams *renP, MandelBoxParams *boxP)
36c32
<   FILE *fp; 
---
>   FILE *fp;
38a35,36
>   char buf[BUF_SIZE];
>   
41a40
> 
68,86c67
< 	  if (frame_no == 0){
< 	  	  sscanf(buf, "%f %f %f", d, d+1, d+2);
< 		  camera_position_array[0] = *d;
< 		  camera_position_array[1] = *(d+1);
< 		  camera_position_array[2] = *(d+2);
< 	  }
< 	  else{
< 		  // camera_position_array[0] = camera_position_array[0] + camera_position_changes_array[0];
< 		  // camera_position_array[1] = camera_position_array[1] + camera_position_changes_array[1];
< 		  // camera_position_array[2] = camera_position_array[2] + camera_position_changes_array[2];
< 		  *d  = camera_position_array[0];
< 		  *(d+1) = camera_position_array[1];
< 		  *(d+2) = camera_position_array[2];
< 		  // printf("step_x: %f\t step_y: %f\t step_z: %f\n", camera_position_changes_array[0]
< 		  // 	, camera_position_changes_array[1] , camera_position_changes_array[2]);
< 		  printf("camPos: %f %f %f\n", *d, *(d+1) , *(d+2));
< 
< 	  }
< 	  
---
> 	  sscanf(buf, "%f %f %f", d, d+1, d+2);
91d71
< 	  if (frame_no == 0){
93,109d72
< 	  	  camera_angle_array[0] = *d;
< 		  camera_angle_array[1] = *(d+1);
< 		  camera_angle_array[2] = *(d+2);
< 	  }
< 	  else
< 	  {
< 		  // camera_angle_array[0] = camera_angle_array[0] + camera_angle_changes_array[0];
< 		  // camera_angle_array[1] = camera_angle_array[1] + camera_angle_changes_array[1];
< 		  // camera_angle_array[2] = camera_angle_array[2] + camera_angle_changes_array[2];
< 		  *d  = camera_angle_array[0];
< 		  *(d+1) = camera_angle_array[1];
< 		  *(d+2) = camera_angle_array[2];
< 
< 		  // printf("Ang_step_x: %f\t Ang_step_y: %f\t Ang_step_z: %f\n", camera_angle_changes_array[0]
< 		  // 	, camera_angle_changes_array[1] , camera_angle_changes_array[2]);
< 		  printf("camAng: %f %f %f\n", *d, *(d+1) , *(d+2));
< 	  }
Only in ../final/: getparams.o
Only in .: ._imageBulb.bmp
diff -r ../final/init3D.c ./init3D.c
48d47
<   
Only in ../final/: init3D.o
diff -r ../final/main.cc ./main.cc
27,30c27
< void getParameters(char *filename, float *camera_position_array, float *camera_position_changes_array, 
<   float *camera_angle_array, float *camera_angle_changes_array,
<    int frame_no, CameraParams *camera_params, RenderParams *renderer_params,
<        MandelBoxParams *mandelBox_paramsP);
---
> void getParameters(char *filename, CameraParams *camera_params, RenderParams *renderer_params, MandelBoxParams *mandelBox_params);
32,37c29,30
< int renderFractal(const CameraParams &camera_params, float *camera_position_array, float *camera_position_changes_array, 
<  int move_position, float *camera_angle_array, float *camera_angle_changes_array, int frame_no,
<  const RenderParams &renderer_params, unsigned char* image);
< void saveBMP      (const char* filename, int frame_no, const unsigned char* image, int width, int height);
< 
< MandelBoxParams mandelBox_params;
---
> void renderFractal(const CameraParams &camera_params, const RenderParams &renderer_params, unsigned char* image, MandelBoxParams &mandelBox_params);
> void saveBMP      (const char* filename, const unsigned char* image, int width, int height);
41c34
<   
---
>   MandelBoxParams mandelBox_params;
44,51c37,38
<   float camera_position_array[3];
<   float camera_position_changes_array[3] = {0 , 0 , 0};
<   float camera_angle_array[3];
<   float camera_angle_changes_array[3] = {0 , 0 , 0};
<   int frame_counter = 0;
<   int move_position = 1;
<   // int clear_position_changes;
<   while (frame_counter < 7200){
---
>   
>   getParameters(argv[1], &camera_params, &renderer_params, &mandelBox_params);
53,56d39
<   getParameters(argv[1], camera_position_array, camera_position_changes_array, camera_angle_array, 
<     camera_angle_changes_array, frame_counter,
<    &camera_params, &renderer_params, &mandelBox_params);
<   // printf("%f\n", camera_position_array[0]);
62,64c45
< 
<   move_position = renderFractal(camera_params, camera_position_array, camera_position_changes_array, move_position,
<     camera_angle_array, camera_angle_changes_array, frame_counter, renderer_params, image);
---
>   renderFractal(camera_params, renderer_params, image, mandelBox_params);
66c47
<   saveBMP(renderer_params.file_name , frame_counter, image, renderer_params.width, renderer_params.height);
---
>   saveBMP(renderer_params.file_name, image, renderer_params.width, renderer_params.height);
69,70c50
<   frame_counter++;
<   }
---
> 
Only in ../final/: main.o
diff -r ../final/makefile ./makefile
3,4c3,4
< FLAGS    = -O3 -Wall
< CFLAGS   = $(FLAGS) 
---
> FLAGS    = -O3 -Wall -std=gnu++0x -fopenmp -g -pg #-E
> CFLAGS   = $(FLAGS)
6c6,12
< LDFLAGS  = -lm 
---
> LDFLAGS  = -lm -L.
> 
> ifeq ($(MAKECMDGOALS),mandelbulb)
> 	CFLAGS+=-DBULB
> 	CXXFLAGS+=-DBULB
> else
> endif
13a20,22
> mandelbulb: main.o print.o timing.o savebmp.o getparams.o 3d.o getcolor.o distance_est.o \
> 	mandelboxde.o raymarching.o renderer.o init3D.o
> 	$(CC) -o $@ $? $(CFLAGS) $(LDFLAGS)
16c25,26
< 	rm *.o $(PROGRAM_NAME) $(EXEEXT) *~
---
> 	rm -f *.o mandelbulb $(PROGRAM_NAME) $(EXEEXT) *~
> 
Only in ../final/: mandelbox
diff -r ../final/mandelboxde.cc ./mandelboxde.cc
1,74d0
< /*
<    This file is part of the Mandelbox program developed for the course
<     CS/SE  Distributed Computer Systems taught by N. Nedialkov in the
<     Winter of 2015-2016 at McMaster University.
< 
<     Copyright (C) 2015-2016 T. Gwosdz and N. Nedialkov
< 
<     This program is free software: you can redistribute it and/or modify
<     it under the terms of the GNU General Public License as published by
<     the Free Software Foundation, either version 3 of the License, or
<     (at your option) any later version.
< 
<     This program is distributed in the hope that it will be useful,
<     but WITHOUT ANY WARRANTY; without even the implied warranty of
<     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<     GNU General Public License for more details.
< 
<     You should have received a copy of the GNU General Public License
<     along with this program.  If not, see <http://www.gnu.org/licenses/>.
< */
< #include <cmath>
< #include <cstdio>
< #include <algorithm>
< #include "color.h"
< #include "mandelbox.h"
< #include <math.h>
< 
< #define SQR(x) ((x)*(x))
< 
< #define COMPONENT_FOLD(x) { (x) = fabsf(x) <= 1? (x) : copysignf(2,(x))-(x); }
< //check it out
< 
< float MandelBoxDE(const vec3 &p0, const MandelBoxParams &params, float c1, float c2)
< {
<   vec3 p = p0;
<   float rMin2   = SQR(params.rMin);
<   float rFixed2 = SQR(params.rFixed);
<   float escape  = SQR(params.escape_time);
<   float dfactor = 1; 
<   float r2      =-1;
<   const float rFixed2rMin2 = rFixed2/rMin2;
< 
<   int i = 0;
<   while (i< params.num_iter && r2 < escape)
<     {
<       COMPONENT_FOLD(p.x);
<       COMPONENT_FOLD(p.y);
<       COMPONENT_FOLD(p.z);
<       
<       r2 = p.Dot(p);      
< 
<       if (r2<rMin2)
< 	{
< 	  p = p*(rFixed2rMin2);
< 	  dfactor *= (rFixed2rMin2);
< 	}
<       else
<       if ( r2<rFixed2) 
< 	{
< 	  const float t = (rFixed2/r2);
< 	  p = p*(rFixed2/r2);;
< 	  dfactor *= t;
< 	}
<       
< 
<       dfactor = dfactor*fabsf(params.scale)+1.0;      
<       p = p*params.scale+p0;
<       i++;
<     }
<   
<   return  (p.Magnitude() - c1) / dfactor - c2;
< }
< 
< 
Only in .: mandelboxde.h
Only in ../final/: mandelboxde.o
Only in .: NOTES
diff -r ../final/params1.dat ./params1.dat
2,3c2,3
< # location  x,y,z   (7,7,7) (3.2, 1, 6) (1.922303 1.230000 2.876038) 1.8 3 -0.876038
< 1.700226 1.601120 -1.039387
---
> # location  x,y,z   (7,7,7)
> 7 1 7 
5,6c5,6
< 2.207834 1.727085 -1.734110
< # up vector x,y,z;  (0, 1, 3)
---
> 0 1 0 
> # up vector x,y,z;  (0, 1, 0)
12,13c12,13
< #3840 2160 (800 600)
< 400 400
---
> #3840 2160
> 800 600
27c27
< #0
---
> 0
29c29
< frames/image
\ No newline at end of file
---
> image.bmp
\ No newline at end of file
Only in .: paramsBulb.dat
diff -r ../final/params.dat ./params.dat
2,3c2,3
< # location  x,y,z   (7,7,7)
< 14.0 8.0 10.0
---
> # location  x,y,z   (7,7,7)   14.0 8.0 10.0    4.0 4.0 3.0
> -14.0 -8.0 -10.0
8,9c8,9
< # field of view     (1)
< 1.1
---
> # field of view     (1.1)  			# KA higher FOV means more in view and higher computation time. Higher FOV means more zoomed out
> 1
14c14
< -4
---
> -4.0
16c16
< # scale, rMin, rFixed  (2 0.5 1)
---
> # scale, rMin, rFixed  (2 0.5 1)  # KA scale is the order of the box?
Only in ../final/: params_test.dat
Only in .: prepare_git
diff -r ../final/print.c ./print.c
40c40
<   fprintf( stderr, delete_space);
---
>   fprintf(stderr, "%s", delete_space);
Only in ../final/: print.o
Only in .: project-2016.pdf
diff -r ../final/raymarching.cc ./raymarching.cc
26a27
> #include "mandelboxde.h"
28,29c29
< extern float DE(const vec3 &p);
< void normal (const vec3 & p, vec3 & normal);
---
> extern float DE(const vec3 &p, MandelBoxParams &mandelBox_params);
31,32c31,54
< float rayMarch(const RenderParams &render_params, const vec3 &from, const vec3  &direction, float eps,
<         pixelData& pix_data, vec3 &vector_of_pixel)
---
> static inline void normal(const vec3 & p, vec3 & normal, MandelBoxParams &mandelBox_params)
> {
>   // compute the normal at p
>   const float sqrt_mach_eps = 3.4527e-04;// 1.4901e-08;
> 
>   float eps = std::max( MAGNITUDE_RET(p), 1.0 )*sqrt_mach_eps;
> 
>   vec3 e1 = {eps, 0,   0};
>   vec3 e2 = {0  , eps, 0};
>   vec3 e3 = {0  , 0, eps};
> 
>   vec3 ppe1 = PLUS(p, e1);
>   vec3 pme1 = SUB(p, e1);
>   vec3 ppe2 = PLUS(p, e2);
>   vec3 pme2 = SUB(p, e2);
>   vec3 ppe3 = PLUS(p, e3);
>   vec3 pme3 = SUB(p, e3);
> 
>   normal = {DE(ppe1,mandelBox_params)-DE(pme1,mandelBox_params), DE(ppe2,mandelBox_params)-DE(pme2,mandelBox_params), DE(ppe3,mandelBox_params)-DE(pme3,mandelBox_params)};
>   
>   NORMALIZE(normal);
> }
> 
> void rayMarch(const RenderParams &render_params, const vec3 &from, const vec3  &direction, float eps, pixelData& pix_data, MandelBoxParams &mandelBox_params)
45,46c67,70
<       p = from + direction * totalDist;
<       dist = DE(p);
---
>       //p = from + direction * totalDist;
>       p = MULK(direction, totalDist);
>       p = PLUS(p, from);
>       dist = DE(p,mandelBox_params);
55a80
>   //vec3 hitNormal; //XXX KA not used?
58,59d82
<      
<      
67,74c90,92
<       const vec3 normPos = p - direction * epsModified;
<       
<       // printf("normPos: x: %f y: %f z: %f\n", normPos.x, normPos.y, normPos.z);
<       normal(normPos, pix_data.normal);
<       
<       
< 
<   
---
>       vec3 normPos = MULK(direction, epsModified); // XXX was const
>       normPos = SUB(p, normPos);
>       normal(normPos, pix_data.normal, mandelBox_params);
76c94
<   else {
---
>   else 
79,101d96
<     // printf("x: %f y: %f z: %f\n", vector_of_pixel.x, vector_of_pixel.y, vector_of_pixel.z );
<   }
<   vector_of_pixel = pix_data.hit;
< 
<   return dist; 
< }
< 
< 
< void normal(const vec3 & p, vec3 & normal)
< {
<   // compute the normal at p
<   // const double sqrt_mach_eps = 1.4901e-08;
<   const float sqrt_mach_eps = 3.4527e-04;
< 
<   float eps = std::max( p.Magnitude(), (float)(1.0))*sqrt_mach_eps;
< 
<   vec3 e1(eps, 0,   0);
<   vec3 e2(0  , eps, 0);
<   vec3 e3(0  , 0, eps);
<   
<   normal = vec3(DE(p+e1)-DE(p-e1), DE(p+e2)-DE(p-e2), DE(p+e3)-DE(p-e3));
<   
<   normal.Normalize();
Only in ../final/: raymarching.o
diff -r ../final/renderer.cc ./renderer.cc
22a23,25
> 
> #include "omp.h"
> 
28c31,32
< #include <math.h>
---
> #include "getcolor.h"
> #include "math.h"
29a34,35
> extern float getTime();
> extern void   printProgress( float perc, float time );
34,35c40
< extern float rayMarch (const RenderParams &render_params, const vec3 &from, const vec3  &to, float eps, pixelData &pix_data,
<   vec3 &vector_of_pixel);
---
> extern void rayMarch (const RenderParams &render_params, const vec3 &from, const vec3  &to, float eps, pixelData &pix_data, MandelBoxParams &mandelBox_params);
37c42,44
<           const vec3 &from, const vec3  &direction);
---
> 		      const vec3 &from, const vec3  &direction);
> 
> extern void foo();
39,42c46
< int renderFractal(const CameraParams &camera_params, float *camera_position_array,
<   float *camera_position_changes_array, int move_position,
< float *camera_angle_array, float *camera_angle_changes_array, int frame_no,
<   const RenderParams &renderer_params, unsigned char* image)
---
> void renderFractal(const CameraParams &camera_params, const RenderParams &renderer_params, unsigned char* image, MandelBoxParams &mandelBox_params)
44,46c48,49
<   const float eps = powf(10.0, renderer_params.detail); 
<   float farPoint[3];
<   vec3 to, from, test_vector;
---
>   const float eps = pow(10.0, renderer_params.detail); 
>   vec3 from;
48c51
<   from.SetfloatPoint(camera_params.camPos);
---
>   SET_POINT(from,camera_params.camPos)
52c55,56
< 
---
>   int j;
>   //float time = getTime();
54,185c58,91
<   float *distance_to_pixel_array;
<   float *distance_to_point_array;
<   vec3 *distance_vector_points;
<   float step_size = 0.01;
<  
< 
<   int pin_spacing = 5;
<   // int check_frame_path = 30;
<   distance_to_pixel_array =  (float *)malloc(sizeof(float) * (width*height/pin_spacing));
<   distance_to_point_array =  (float *)malloc(sizeof(float) * (width*height/pin_spacing));
<   distance_vector_points =  (vec3 *)malloc(sizeof(vec3) * (width*height/pin_spacing));
< 
<   pixelData pix_data;
<    
<   float time = getTime();
<   vec3 color;
<   
<   int i,j,k;
<   int pixel_count = 0;
<   int distance_to_pixel_index = 0;
< 
<   for(j = 0; j < height; j++)
<     {
<       //for each column pixel in the row
<       for(i = 0; i <width; i++)
<   {
<       // get point on the 'far' plane
<       // since we render one frame only, we can use the more specialized method
<       UnProject(i, j, camera_params, farPoint);
< 
< 
<       // to = farPoint - camera_params.camPos
<       to = Subtractfloatfloat(farPoint,camera_params.camPos);
<       
<       to.Normalize();
<       vec3 test_vector;
<       //render the pixel
<       float distance_to_pixel = rayMarch(renderer_params, from, to, eps, pix_data, test_vector);
< 
<       if (i%pin_spacing == 0 && j%pin_spacing == 0){
< 
<         distance_to_pixel_array[distance_to_pixel_index] = distance_to_pixel;
<         distance_vector_points[distance_to_pixel_index] = pix_data.hit;
<         float new_distance = sqrtf(powf(pix_data.hit.x -camera_position_array[0],2)
<        + powf(pix_data.hit.y-camera_position_array[1],2) + powf(pix_data.hit.z -camera_position_array[3],2));
<         distance_to_point_array[distance_to_pixel_index] = new_distance;
< 
<         distance_to_pixel_index++; 
< 
<     }
< 
<       //get the colour at this pixel
<       color = getColour(pix_data, renderer_params, from, to);
<         
<       //save colour into texture
<       k = (j * width + i)*3;
<       image[k+2] = (unsigned char)(color.x * 255);
<       image[k+1] = (unsigned char)(color.y * 255);
<       image[k]   = (unsigned char)(color.z * 255);
<       pixel_count++;
<   }
<       printProgress((j+1)/(float)height,getTime()-time);
< 
<     }
< 
< if (move_position == 1){
<   float vector_distance = sqrtf(powf(camera_angle_array[0] -camera_position_array[0],2)
<      + powf(camera_angle_array[1] -camera_position_array[1],2) + powf(camera_angle_array[3] -camera_position_array[3],2));
< 
<   float t = step_size/vector_distance;
<   camera_position_array[0] += t*(camera_angle_array[0]-camera_position_array[0]);
<   camera_position_array[1] += t*(camera_angle_array[1]-camera_position_array[1]);
<   camera_position_array[2] += t*(camera_angle_array[2]-camera_position_array[2]);
<  
<     if ( vector_distance < 0.4 || frame_no == 0){
<       move_position = 0;
<       int max_index = 0;
<       int found_flag = 0;
<       float current_max = 0;
<       float current_max_distance = 0;
<       vec3 current_max_vector_point; 
<       while (found_flag == 0){
<         
<           if (distance_to_pixel_array[max_index] < 0.0002){
<               current_max = distance_to_pixel_array[max_index];
<               current_max_vector_point = distance_vector_points[max_index];
<               current_max_distance = distance_to_point_array[max_index];
<               found_flag = 1;
<           }
<           max_index++;
<       }
<       
<       for (;max_index < distance_to_pixel_index; max_index++){
<           if (distance_to_pixel_array[max_index] > current_max && distance_to_pixel_array[max_index] < 0.0002){
<               current_max = distance_to_pixel_array[max_index];
<               current_max_vector_point = distance_vector_points[max_index];
<               current_max_distance = distance_to_point_array[max_index];        
<           }
< 
<       }
<       camera_angle_changes_array[0] = current_max_vector_point.x;
<       camera_angle_changes_array[1] = current_max_vector_point.y;
<       camera_angle_changes_array[2] = current_max_vector_point.z;
<       
<       
< 
<     }
< 
< }
< else
< {
< float vector_distance = sqrtf(powf(camera_angle_changes_array[0] -camera_angle_array[0],2)
<      + powf(camera_angle_changes_array[1] -camera_angle_array[1],2) 
<      + powf(camera_angle_changes_array[3] -camera_angle_array[3],2));
< 
<   float t = 0.10;//*(step_size/vector_distance);
<   if (vector_distance < 0.05 ){
<     camera_angle_array[0] = camera_angle_changes_array[0];
<     camera_angle_array[1] = camera_angle_changes_array[1];
<     camera_angle_array[2] = camera_angle_changes_array[2];
< 
<     move_position = 1;
<     
<   }
<   camera_angle_array[0] += t*(camera_angle_changes_array[0]-camera_angle_array[0]);
<   camera_angle_array[1] += t*(camera_angle_changes_array[1]-camera_angle_array[1]);
<   camera_angle_array[2] += t*(camera_angle_changes_array[2]-camera_angle_array[2]);
< 
<  
< }
< 
< 
---
> #pragma omp parallel for default(shared) schedule(dynamic) num_threads(4)
>   for(j = 0; j < height; j++){
>       int i=0;  
>       for(i = 0; i <width; i++){
> 	  pixelData pix_data;
>   	  vec3 color;
> 	  float farPoint[3];
> 	  vec3 to;
> 
> 	  foo();
> 
> 	  // get point on the 'far' plane
> 	  // since we render one frame only, 
> 	  // we can use the more specialized method
> 	  UnProject(i, j, camera_params, farPoint);
> 	  
> 	  // to = farPoint - camera_params.camPos
>           to = SUBDUBDUB(farPoint, camera_params.camPos);
> 	  NORMALIZE(to);
> 	  
> 	  //render the pixel
> 	  rayMarch(renderer_params, from, to, eps, pix_data, mandelBox_params);
> 
> 	  //get the colour at this pixel
> 	  color = getColour(pix_data, renderer_params, from, to);
> 
> 	  //save colour into texture
> 	  int k = (j * width + i)*3;
> 	  image[k+2] = (unsigned char)(color.x * 255);
> 	  image[k+1] = (unsigned char)(color.y * 255);
> 	  image[k]   = (unsigned char)(color.z * 255);
> 	} // inner for
>       //printProgress((j+1)/(float)height,getTime()-time);
>     }//end of outer for
188,194d93
< 
< 
<   free(distance_to_pixel_array);
<   free(distance_to_point_array);
< 
< 
<     return move_position;
196,200d94
< 
< 
< 
< 
< 
Only in ../final/: renderer.o
Only in .: run.sh
diff -r ../final/savebmp.c ./savebmp.c
25d24
< #include <string.h>
27c26
< void saveBMP(const char* filename, int frame_no, const unsigned char* result, int w, int h){
---
> void saveBMP(const char* filename, const unsigned char* result, int w, int h){
51,57c50
< 	char filename_str[80];
< 	char suffix[15];
< 	int frame_offset = frame_no + 72;
< 	sprintf(suffix, "%d.bmp", frame_offset);
< 	strcpy(filename_str, filename);
< 	strcat(filename_str, suffix);
< 	f = fopen(filename_str,"wb");
---
> 	f = fopen(filename,"wb");
60d52
< 	printf("Writing to: %s\n", filename_str);
Only in ../final/: savebmp.o
Only in .: scpf
Only in .: scpt
Only in .: ssha
Only in ../final/: timing.o
diff -r ../final/vector3d.h ./vector3d.h
4c4,9
< #include <cmath>
---
> #ifdef _OPENACC
> #include <accelmath.h>
> #else
> #include <math.h>
> //include <cmath>
> #endif
6,120c11,58
< class vec3
< {
< public:
< 	// Data
< 	float x, y, z;
< 
< 	// Ctors
< 	vec3( float InX, float InY, float InZ ) : x( InX ), y( InY ), z( InZ )
< 		{
< 		}
< 	void SetfloatPoint( const float *v ) {  x=v[0]; y=v[1]; z=v[2]; }
< 
< 	vec3( ) : x(0), y(0), z(0)
< 		{
< 		}
< 
< 	// Operator Overloads
< 	inline bool operator== (const vec3& V2) const 
< 		{
< 		return (x == V2.x && y == V2.y && z == V2.z);
< 		}
< 
< 	inline vec3 operator+ (const vec3& V2) const 
< 		{
< 		return vec3( x + V2.x,  y + V2.y,  z + V2.z);
< 		}
< 	inline vec3 operator- (const vec3& V2) const
< 		{
< 		return vec3( x - V2.x,  y - V2.y,  z - V2.z);
< 		}
< 	inline vec3 SubP(const float *v) const
< 		{
< 		  return vec3( x - v[0],  y - v[1],  z - v[2]);
< 		}
< 
< 	inline vec3 operator- ( ) const
< 		{
< 		return vec3(-x, -y, -z);
< 		}
< 
< 	inline vec3 operator/ (float S ) const
< 		{
< 		float fInv = 1.0 / S;
< 		return vec3 (x * fInv , y * fInv, z * fInv);
< 		}
< 	inline vec3 operator/ (const vec3& V2) const
< 		{
< 		return vec3 (x / V2.x,  y / V2.y,  z / V2.z);
< 		}
< 	inline vec3 operator* (const vec3& V2) const
< 		{
< 		return vec3 (x * V2.x,  y * V2.y,  z * V2.z);
< 		}
< 	inline vec3 operator* (float S) const
< 		{
< 		return vec3 (x * S,  y * S,  z * S);
< 		}
< 	inline vec3 operator+ (float S) const
< 		{
< 		return vec3 (x + S,  y + S,  z + S);
< 		}
< 	inline vec3 operator- (float S) const
< 		{
< 		return vec3 (x - S,  y - S,  z - S);
< 		}
< 
< 	inline void operator+= ( const vec3& V2 )
< 		{
< 		x += V2.x;
< 		y += V2.y;
< 		z += V2.z;
< 		}
< 	inline void operator-= ( const vec3& V2 )
< 		{
< 		x -= V2.x;
< 		y -= V2.y;
< 		z -= V2.z;
< 		}
< 
< 	inline float operator[] ( int i )
< 		{
< 		if ( i == 0 ) return x;
< 		else if ( i == 1 ) return y;
< 		else return z;
< 		}
< 
< 	// Functions
< 	inline float Dot( const vec3 &V1 ) const
< 		{
< 		return V1.x*x + V1.y*y + V1.z*z;
< 		}
< 
< 	// These require math.h for the sqrt function
< 	float Magnitude( ) const
< 		{
< 		//cmath cast added
< 		return  sqrtf(x*x + y*y + z*z);
< 		}
< 
< 	inline void Normalize()
< 		{
< 		float fMag = ( x*x + y*y + z*z );
< 		if (fMag == 0) {return;}
< 		//cmath cast added
< 		float fMult = (1.0/sqrtf(fMag));            
< 		x *= fMult;
< 		y *= fMult;
< 		z *= fMult;
< 		return;
< 		}
< };
< 
< inline vec3 Subtractfloatfloat(const float *d1, const float *d2)
< {
<   return vec3(d1[0]-d2[0], d1[1]-d2[1], d1[2]-d2[2]);
---
> // http://stackoverflow.com/questions/13706809/structs-in-c-with-initial-values
> typedef struct {
>   float x, y, z;
> }  vec3;
> 
> // SetDoublePoint
> #define SET_POINT(p,v) { p.x=v[0]; p.y=v[1]; p.z=v[2]; } 
> 
> // RETURNS VECTOR
> //XXX used them like this  "vec3 my_vector = PLUS(v1,v2);"
> #define EQUAL(v1,v2) (v1.x == v2.x && v1.y == v2.y && v1.z == v2.z) //inline bool operator== (const vec3& V2) const
> #define PLUS(v1,v2)  {v1.x+v2.x, v1.y+v2.y, v1.z+v2.z} // inline vec3 operator+ (const vec3& V2) const //XXX different behavior then before, now it modifies v1 in place instead of returning new vec3
> #define SUB(v1,v2)  {v1.x-v2.x, v1.y-v2.y, v1.z-v2.z} // inline vec3 operator- (const vec3& V2) const //XXX different behavior then before, now it modifies v1 in place instead of returning new vec3
> #define SUBP(v1,arr) {v1.x-arr[0], v1.y-arr[1], v1.z-arr[2]} // inline vec3 SubP(const double *v) const
> #define NEG(v1)      {-v1.x, -v1.y, -v1.z} //inline vec3 operator- ( ) const
> #define DIVK(v1,k)  {v1.x=v1.x/k; v1.y=v1.y/k; v1.z=v1.z/k;} // inline vec3 operator/ (double S ) const // XXX need more efficient
> #define DIV(v1,v2) { v1.x/v2.x, v1.y/v2.y, v1.z/v2.z}  // inline vec3 operator/ (const vec3& V2) const
> #define MUL(v1,v2) { v1.x*v2.x, v1.y*v2.y, v1.z*v2.z} // inline vec3 operator* (const vec3& V2) const
> #define MULK(v1,k)  { v1.x*k, v1.y*k, v1.z*k} // inline vec3 operator* (double S) const
> #define ADD(v1,k)  { v1.x=v1.x+k; v1.y=v1.y+k;  v1.z=v1.z+k;} // inline vec3 operator+ (double S) const
> #define SUBK(v1,k) { v1.x-k, v1.y-k, v1.z-k} 	// inline vec3 operator- (double S) const
> 
> // MODIFIES FIRST VECTOR
> #define PLUSEQUAL(v1,v2)  { v1.x=v1.x+v2.x; v1.y=v1.y+v2.y; v1.z=v1.z+v2.z; } // inline void operator+= ( const vec3& V2 )
> #define SUBEQUAL(v1,v2)  { v1.x=v1.x+v2.x; v1.y=v1.y+v2.y; v1.z=v1.z+v2.z; } // inline void operator-= ( const vec3& V2 )
> //TODO KA is this necessary to convert? inline double operator[] ( int i )
> #define DOTSELF(d,v1)         {  d=( v1.x*v1.x + v1.y*v1.y + v1.z*v1.z );    }
> #define DOT(d,v1,v2)         {  d=( v1.x*v2.x + v1.y*v2.y + v1.z*v2.z );    }
> #define DOTRET(v1,v2)        ( v1.x*v2.x + v1.y*v2.y + v1.z*v2.z )
> #define MAGNITUDE(m,p) 	({ m=sqrt( p.x*p.x + p.y*p.y + p.z*p.z ); })
> #define MAGNITUDE_RET(p) 	(sqrt(p.x*p.x + p.y*p.y + p.z*p.z))
> #define NORMALIZE(p) {					\
>     float fMag = ( p.x*p.x + p.y*p.y + p.z*p.z );	\
>     if (fMag != 0)					\
>       {							\
> 	float fMult = 1.0/sqrt(fMag);			\
> 	p.x *= fMult;					\
> 	p.y *= fMult;					\
> 	p.z *= fMult;					\
>       }							\
>   }
> #define SUBDUBDUB(d1,d2)  {d1[0]-d2[0], d1[1]-d2[1], d1[2]-d2[2]} // inline vec3 SubtractDoubleDouble(const double *d1, const double *d2) 
> // Not SubP!
> #define SUBTRACT_POINT(p,v,u)			\
>   {						\
>   p.x=(v[0])-(u[0]);				\
>   p.y=(v[1])-(u[1]);				\
>   p.z=(v[2])-(u[2]);				\
122,126c60,64
< 
< inline float clamp(float d, float min, float max) 
< {
<   const float t = d < min ? min : d;
<   return t > max ? max : t;
---
> #define MAX(a,b)      ( ((a)>(b))? (a):(b))
> #define VEC(v,a,b,c) vec3 v= {a,b,c}
> #define CLAMP(d, min, max) { \
> 	float t=(d < min ? min : d); \
> 	d=(t > max ? max : t);\
128,134c66,69
< 
< 
< inline void clamp(vec3 &v, float min, float max) 
< {
<   v.x = clamp(v.x,min,max);
<   v.y = clamp(v.y,min,max);
<   v.z = clamp(v.z,min,max);
---
> #define CLAMPVEC(v1, min, max) { \
> 	CLAMP(v1.x,min,max); \
> 	CLAMP(v1.y,min,max); \
> 	CLAMP(v1.z,min,max);  \
136a72,73
> // Defined by Kyle
> #define COPY(v1) {v1.x, v1.y, v1.z}
137a75,76
> #define SHOW(v1)     {printf("[%f,%f,%f]\n", v1.x, v1.y, v1.z); fflush(stdout);}
> #define SHOWMSG(msg,v1) {printf("%s: [%f,%f,%f]\n", msg, v1.x, v1.y, v1.z); fflush(stdout);}
